# Fill in your name, student ID, and email address in this file.
# If you are working in a team, fill out the information for both team 
# members.

# SUBMIT THE LAB ONLY ONCE (from only one partner). This file will be
# automatically parsed in order to give both team members credit for the
# lab.

# You need to fill in the EXERCISE sections describing your solutions
# for Tasks 1, 2, and 3, as well as write the corresponding code.
# If you did one or more extra credit problems, indicate which one in the
# appropriate section below (remove the # sign first). If you have any other
# information you'd like us to know, please add it at the end of the file.

# Partner 1
Name: Daryn Arakawa
Student ID: 504-132-711
Email: daryn.arakawa@gmail.com

# Partner 2 (if you're working in a team)
Name: Austin Lazaro
Student ID: 404-158-419
Email: aust412@gmail.com

# EXERCISE 1: What method you used to make your peer download and upload
#    files in parallel?  (~1-3 sentences)
We used forking inside int main() in order to download and upload in parallel. We first take care of downloads in parallel, then wait for all download operations to finish (i.e. we wait for all forked children to exit). Then, we move on to the uploads using the same method. 

# EXERCISE 2A: What conditions did you find and fix that would have
#    triggered a buffer overrun bug?  (~1-3 sentences each)
strcpy seemed to have been causing a buffer overrun bug in start_download and
task_download. We used strncpy instead, and used FILENAMESIZ to give a max
size for copying.

# EXERCISE 2B: What other robustness problems did you fix?  (~1-3 sentences
#    each)

1. Put a cap on the size of download files with a #define variable MAXSIZ,
and set it equal to four times the TASKBUFSIZ. If a a single transaction exceeds this maximum, the download is aborted. 

2. Increased the number of tasks we could run be increasing TASKBUFSIZ to 51200.

3. Made sure that all the requested files were in the correct directory, by comparing the directory of the requested file with the current working directory. This was done using the C functions getcwd() and realpath(). If the directory of the requested file does not match the current working directory, the file request is not served. 

# Add any other information you'd like us to know below this line.
